import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:touchgrass/screens/register_screen.dart'; // Use the correct import path
import 'package:touchgrass/viewmodels/register_viewmodel.dart'; // Use the correct import path
import 'package:touchgrass/core/utils/result.dart'; // Use the correct import path
import 'package:touchgrass/core/utils/command.dart'; // Use the correct import path

// Import the generated mocks
import 'register_screen_test.mocks.dart'; // This file will be generated by build_runner

@GenerateMocks([RegisterViewmodel])
void main() {
  // --- Widget Tests for UI Inputs and Button ---
  group('Register Screen Widget Tests', ()
  {
    late MockRegisterViewmodel mockViewModel;

    setUp(() {
      // Create a new mock ViewModel before each widget test
      mockViewModel = MockRegisterViewmodel();
      // Stub the register command to avoid real execution in widget tests
      when(mockViewModel.register).thenReturn(
          Command1<void, (String, String, String, String?, String?, String?)>((
              _) async {return Result.ok("");}));

      // Stub the validator methods in the mock ViewModel
      // These stubs will be called by the TextFormField validators
      when(mockViewModel.validateUserName(any)).thenReturn(null);
      when(mockViewModel.validateEmail(any)).thenReturn(null);
      when(mockViewModel.validatePassword(any)).thenReturn(null);
      // Note: The Confirm Password validator is still in the screen's state
      // If you moved this to the ViewModel as well, you would stub it here.

      // Stub other ViewModel properties if needed for the UI tests (e.g., loading states)
      // when(mockViewModel.isLoading).thenReturn(ValueNotifier<bool>(false));
    });

    testWidgets(
        'should display all required input fields and a register button', (
        WidgetTester tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: RegisterScreen(viewModel: mockViewModel),
        ),
      );

      // Verify that the key input fields are present
      expect(find.text('Username'), findsOneWidget);
      expect(find.text('Email'), findsOneWidget);
      expect(find.text('Password'), findsOneWidget);
      expect(find.text('Confirm Password'), findsOneWidget);

      // Verify that the optional input fields are present
      expect(find.text('First Name'), findsOneWidget);
      expect(find.text('Last Name'), findsOneWidget);

      // Verify that the "Date of Birth" text field is present (implicitly tested by finding the tap detector)
      expect(find.text('Date of Birth'), findsOneWidget);

      // Verify that the Register button is present
      expect(find.text('Register'), findsOneWidget);
    });

    testWidgets('should show password when visibility icon is tapped', (
        WidgetTester tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: RegisterScreen(viewModel: mockViewModel),
        ),
      );

      final passwordField = find.text('Password');
      expect(passwordField, findsOneWidget);

      final visibilityIcon = find.byIcon(Icons.visibility);
      expect(visibilityIcon, findsOneWidget);

      // Tap the visibility icon
      await tester.tap(visibilityIcon);
      await tester.pump();
    });

    testWidgets('should show confirm password when visibility icon is tapped', (
        WidgetTester tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: RegisterScreen(viewModel: mockViewModel),
        ),
      );

      final confirmPasswordField = find.text('Confirm Password');
      expect(confirmPasswordField, findsOneWidget);

      // Find the second visibility icon (for confirm password)
      final visibilityIcon = find.byIcon(Icons.visibility).at(1);
      expect(visibilityIcon, findsOneWidget);

      // Tap the visibility icon
      await tester.tap(visibilityIcon);
      await tester.pump();

    });

    testWidgets(
        'should call viewModel.register.execute when Register button is tapped and form is valid', (
        WidgetTester tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: RegisterScreen(viewModel: mockViewModel),
        ),
      );

      // Fill in valid details (validators in ViewModel are stubbed to return null)
      await tester.enterText(
          find.text('Username'), 'testuser123');
      await tester.enterText(
          find.text('Email'),
          'test.user@example.com');
      await tester.enterText(
          find.text('Password'), 'password123');
      await tester.enterText(
          find.text('Confirm Password'),
          'password123');
      // Fill optional fields
      await tester.enterText(
          find.text('First Name'), 'John');
      await tester.enterText(
          find.text('Last Name'), 'Doe');

      // Simulate selecting a date (assuming Date of Birth input is a tap detector)
      await tester.tap(find.text('Date of Birth'));
      await tester.pumpAndSettle();

      // Tap the Register button
      await tester.tap(find.text('Register'));
      await tester.pump();

      // Verify that the register command was executed with the correct arguments
      verify(mockViewModel.register.execute(
            ('testuser123', 'test.user@example.com', 'password123', 'John', 'Doe', any),
      )).called(1);
    });

    testWidgets(
        'should not call viewModel.register.execute when Register button is tapped and form is invalid', (
        WidgetTester tester) async {
      await tester.pumpWidget(
        MaterialApp(
          home: RegisterScreen(viewModel: mockViewModel),
        ),
      );

      // Fill in invalid details (e.g., short username, stub the validator to return an error)
      when(mockViewModel.validateUserName(any)).thenReturn(
          'Username is too short');
// Fill in invalid details (e.g., short username, stub the validator to return an error)
      when(mockViewModel.validateUserName(any)).thenReturn(
          'Username is too short');

// Enter an invalid username
      await tester.enterText(
        find.text( 'Username'),
        'ab',
      );

// Fill in other valid details
      await tester.enterText(
        find.text( 'Email'),
        'test.user@example.com',
      );
      await tester.enterText(
        find.text( 'Password'),
        'password123',
      );
      await tester.enterText(
        find.text('Confirm Password'),
        'password123',
      );

// Fill optional fields
      await tester.enterText(
        find.text('First Name'),
        'John',
      );
      await tester.enterText(
        find.text( 'Last Name'),
        'Doe',
      );

// Simulate selecting a date (assuming Date of Birth input is a tap detector)
      await tester.tap(find.text('Date of Birth'));
      await tester.pumpAndSettle();

// Tap the Register button
      await tester.tap(find.text('Register'));
      await tester.pump();

// Verify that the register command was NOT executed due to invalid form
      verifyNever(mockViewModel.register.execute);
    });
  });
}